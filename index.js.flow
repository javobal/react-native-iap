/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 */

import * as Apple from "./type/apple";
import { EmitterSubscription } from "react-native";
declare interface Common {
  title: string;
  description: string;
  price: string;
  currency: string;
  localizedPrice: string;
}
declare export var IAPErrorCode: {|
  +E_IAP_NOT_AVAILABLE: "E_IAP_NOT_AVAILABLE", // "E_IAP_NOT_AVAILABLE"
  +E_UNKNOWN: "E_UNKNOWN", // "E_UNKNOWN"
  +E_USER_CANCELLED: "E_USER_CANCELLED", // "E_USER_CANCELLED"
  +E_USER_ERROR: "E_USER_ERROR", // "E_USER_ERROR"
  +E_ITEM_UNAVAILABLE: "E_ITEM_UNAVAILABLE", // "E_ITEM_UNAVAILABLE"
  +E_REMOTE_ERROR: "E_REMOTE_ERROR", // "E_REMOTE_ERROR"
  +E_NETWORK_ERROR: "E_NETWORK_ERROR", // "E_NETWORK_ERROR"
  +E_SERVICE_ERROR: "E_SERVICE_ERROR", // "E_SERVICE_ERROR"
  +E_RECEIPT_FAILED: "E_RECEIPT_FAILED", // "E_RECEIPT_FAILED"
  +E_RECEIPT_FINISHED_FAILED: "E_RECEIPT_FINISHED_FAILED", // "E_RECEIPT_FINISHED_FAILED"
  +E_NOT_PREPARED: "E_NOT_PREPARED", // "E_NOT_PREPARED"
  +E_NOT_ENDED: "E_NOT_ENDED", // "E_NOT_ENDED"
  +E_ALREADY_OWNED: "E_ALREADY_OWNED", // "E_ALREADY_OWNED"
  +E_DEVELOPER_ERROR: "E_DEVELOPER_ERROR", // "E_DEVELOPER_ERROR"
  +E_BILLING_RESPONSE_JSON_PARSE_ERROR: "E_BILLING_RESPONSE_JSON_PARSE_ERROR", // "E_BILLING_RESPONSE_JSON_PARSE_ERROR"
  +E_DEFERRED_PAYMENT: "E_DEFERRED_PAYMENT", // "E_DEFERRED_PAYMENT"
|};

declare export var ProrationModesAndroid: {|
  +IMMEDIATE_WITH_TIME_PRORATION: 1, // 1
  +IMMEDIATE_AND_CHARGE_PRORATED_PRICE: 2, // 2
  +IMMEDIATE_WITHOUT_PRORATION: 3, // 3
  +DEFERRED: 4, // 4
  +UNKNOWN_SUBSCRIPTION_UPGRADE_DOWNGRADE_POLICY: 0, // 0
|};
export interface Discount {
  identifier: string;
  type: string;
  numberOfPeriods: string;
  price: string;
  localizedPrice: string;
  paymentMode: string;
  subscriptionPeriod: string;
}
export type Product<ProductId: string = string> = {
  type: "inapp" | "iap",
  productId: ProductId,
  ...
} & Common;
export type Subscription = {
  type: "subs" | "sub",
  productId: string,
  discounts?: Discount[],
  introductoryPrice?: string,
  introductoryPricePaymentModeIOS?: string,
  introductoryPriceNumberOfPeriodsIOS?: string,
  introductoryPriceSubscriptionPeriodIOS?: string,
  subscriptionPeriodNumberIOS?: string,
  subscriptionPeriodUnitIOS?: string,
  introductoryPriceCyclesAndroid?: string,
  introductoryPricePeriodAndroid?: string,
  subscriptionPeriodAndroid?: string,
  freeTrialPeriodAndroid?: string,
  ...
} & Common;

declare export var PurchaseStateAndroid: {|
  +UNSPECIFIED_STATE: 0, // 0
  +PURCHASED: 1, // 1
  +PENDING: 2, // 2
|};
export interface ProductPurchase {
  productId: string;
  transactionId?: string;
  transactionDate: number;
  transactionReceipt: string;
  purchaseToken?: string;
  dataAndroid?: string;
  signatureAndroid?: string;
  autoRenewingAndroid?: boolean;
  purchaseStateAndroid?: $Values<typeof PurchaseStateAndroid>;
  originalTransactionDateIOS?: string;
  originalTransactionIdentifierIOS?: string;
  isAcknowledgedAndroid?: boolean;
  userIdAmazon?: string;
  userMarketplaceAmazon?: string;
  userJsonAmazon?: string;
  transactionStateIOS?: number;
}
export interface PurchaseResult {
  responseCode?: number;
  debugMessage?: string;
  code?: string;
  message?: string;
}
export interface PurchaseError {
  responseCode?: number;
  debugMessage?: string;
  code?: string;
  message?: string;
  productId?: string;
}
export type InAppPurchase = ProductPurchase;
export type SubscriptionPurchase = {
  autoRenewingAndroid?: boolean,
  originalTransactionDateIOS?: string,
  originalTransactionIdentifierIOS?: string,
  ...
} & ProductPurchase;
export type Purchase = InAppPurchase | SubscriptionPurchase;
declare export var PROMOTED_PRODUCT: any; // "iap-promoted-product"
declare export var InstallSourceAndroid: {|
  +NOT_SET: 0, // 0
  +GOOGLE_PLAY: 1, // 1
  +AMAZON: 2, // 2
|};
declare export function setFallbackInstallSourceAndroid(
  installSourceAndroid: $Values<typeof InstallSourceAndroid>
): void;
declare export function setInstallSourceAndroid(
  installSourceAndroid: $Values<typeof InstallSourceAndroid>
): void;
declare export function getInstallSourceAndroid(): $Values<
  typeof InstallSourceAndroid
>;

/**
 * Init module for purchase flow. Required on Android. In ios it will check wheter user canMakePayment.
 * @returns {Promise<boolean>}
 */
declare export var initConnection: () => Promise<boolean>;
/**
 * End module for purchase flow.
 * @returns {Promise<void>}
 */
declare export var endConnection: () => Promise<void>;
/**
 * @deprecated End module for purchase flow. Required on Android. No-op on iOS.
 * @returns {Promise<void>}
 */
declare export var endConnectionAndroid: () => Promise<void>;
/**
 * Consume all remaining tokens. Android only.
 * This is considered dangerous as you should deliver the purchased feature BEFORE consuming it.
 * If you used this method to refresh Play Store cache (of failed pending payment still marked as failed),
 *   prefer using flushFailedPurchasesCachedAsPendingAndroid
 * @deprecated
 * @returns {Promise<string[]>}
 */
declare export var consumeAllItemsAndroid: () => Promise<string[]>;
/**
 * Consume all 'ghost' purchases (that is, pending payment that already failed but is still marked as pending in Play Store cache). Android only.
 * @returns {Promise<boolean>}
 */
declare export var flushFailedPurchasesCachedAsPendingAndroid: () => Promise<
  string[]
>;
/**
 * Get a list of products (consumable and non-consumable items, but not subscriptions)
 * @param {string[]} skus The item skus
 * @returns {Promise<Product<>[]>}
 */
declare export var getProducts: <SkuType: string>(
  skus: SkuType[]
) => Promise<Product<SkuType>[]>;
/**
 * Get a list of subscriptions
 * @param {string[]} skus The item skus
 * @returns {Promise<Subscription[]>}
 */
declare export var getSubscriptions: (
  skus: string[]
) => Promise<Subscription[]>;
/**
 * Gets an invetory of purchases made by the user regardless of consumption status
 * @returns {Promise<(InAppPurchase | SubscriptionPurchase)[]>}
 */
declare export var getPurchaseHistory: () => Promise<
  (InAppPurchase | SubscriptionPurchase)[]
>;
/**
 * Get all purchases made by the user (either non-consumable, or haven't been consumed yet)
 * @returns {Promise<(InAppPurchase | SubscriptionPurchase)[]>}
 */
declare export var getAvailablePurchases: () => Promise<
  (InAppPurchase | SubscriptionPurchase)[]
>;
/**
 * Request a purchase for product. This will be received in `PurchaseUpdatedListener`.
 * @param {string} sku The product's sku/ID
 * @param {boolean} [andDangerouslyFinishTransactionAutomaticallyIOS] You should set this to false and call finishTransaction manually when you have delivered the purchased goods to the user. It defaults to true to provide backwards compatibility. Will default to false in version 4.0.0.
 * @param {string} [obfuscatedAccountIdAndroid] Specifies an optional obfuscated string that is uniquely associated with the user's account in your app.
 * @param {string} [obfuscatedProfileIdAndroid] Specifies an optional obfuscated string that is uniquely associated with the user's profile in your app.
 * @returns {Promise<InAppPurchase>}
 */
declare export var requestPurchase: (
  sku: string,
  andDangerouslyFinishTransactionAutomaticallyIOS?: boolean,
  obfuscatedAccountIdAndroid?: string,
  obfuscatedProfileIdAndroid?: string
) => Promise<InAppPurchase>;
/**
 * Request a purchase for product. This will be received in `PurchaseUpdatedListener`.
 * @param {string} sku The product's sku/ID
 * @param {boolean} [andDangerouslyFinishTransactionAutomaticallyIOS] You should set this to false and call finishTransaction manually when you have delivered the purchased goods to the user. It defaults to true to provide backwards compatibility. Will default to false in version 4.0.0.
 * @param {string} [oldSkuAndroid] SKU that the user is upgrading or downgrading from.
 * @param {string} [purchaseTokenAndroid] purchaseToken that the user is upgrading or downgrading from (Android).
 * @param {string} [obfuscatedAccountIdAndroid] Specifies an optional obfuscated string that is uniquely associated with the user's account in your app.
 * @param {string} [obfuscatedProfileIdAndroid] Specifies an optional obfuscated string that is uniquely associated with the user's profile in your app.
 * @param {$Values<typeof ProrationModesAndroid>} [prorationModeAndroid] UNKNOWN_SUBSCRIPTION_UPGRADE_DOWNGRADE_POLICY, IMMEDIATE_WITH_TIME_PRORATION, IMMEDIATE_AND_CHARGE_PRORATED_PRICE, IMMEDIATE_WITHOUT_PRORATION, DEFERRED
 * @returns {Promise<void>}
 */
declare export var requestSubscription: (
  sku: string,
  andDangerouslyFinishTransactionAutomaticallyIOS?: boolean,
  oldSkuAndroid?: string,
  purchaseTokenAndroid?: string,
  prorationModeAndroid?: $Values<typeof ProrationModesAndroid>,
  obfuscatedAccountIdAndroid?: string,
  obfuscatedProfileIdAndroid?: string
) => Promise<SubscriptionPurchase>;
/**
 * Request a purchase for product. This will be received in `PurchaseUpdatedListener`.
 * @param {string} sku The product's sku/ID
 * @returns {Promise<void>}
 */
declare export var requestPurchaseWithQuantityIOS: (
  sku: string,
  quantity: number
) => Promise<InAppPurchase>;
/**
 * Finish Transaction (iOS only)
 *    Similar to `consumePurchaseAndroid`. Tells StoreKit that you have delivered the purchase to the user and StoreKit can now let go of the transaction.
 *    Call this after you have persisted the purchased state to your server or local data in your app.
 *    `react-native-iap` will continue to deliver the purchase updated events with the successful purchase until you finish the transaction. **Even after the app has relaunched.**
 * @param {string} transactionId The transactionId of the function that you would like to finish.
 * @returns {Promise<void>}
 */
declare export var finishTransactionIOS: (
  transactionId: string
) => Promise<void>;
/**
 * Finish Transaction (both platforms)
 *    Abstracts `finishTransactionIOS`, `consumePurchaseAndroid`, `acknowledgePurchaseAndroid` in to one method.
 * @param {{[key: string]: any}} purchase The purchase that you would like to finish.
 * @param {boolean} isConsumable Checks if purchase is consumable. Has effect on `android`.
 * @param {string} developerPayloadAndroid Android developerPayload.
 * @returns {Promise<string | void>}
 */
declare export var finishTransaction: (
  purchase: InAppPurchase | ProductPurchase,
  isConsumable?: boolean,
  developerPayloadAndroid?: string
) => Promise<string | void>;
/**
 * Clear Transaction (iOS only)
 *    Finish remaining transactions. Related to issue #257 and #801
 *      link : https://github.com/dooboolab/react-native-iap/issues/257
 *             https://github.com/dooboolab/react-native-iap/issues/801
 * @returns {Promise<void>}
 */
declare export var clearTransactionIOS: () => Promise<void>;
/**
 * Clear valid Products (iOS only)
 *    Remove all products which are validated by Apple server.
 * @returns {void}
 */
declare export var clearProductsIOS: () => Promise<void>;
/**
 * Acknowledge a product (on Android.) No-op on iOS.
 * @param {string} token The product's token (on Android)
 * @returns {Promise<PurchaseResult | void>}
 */
declare export var acknowledgePurchaseAndroid: (
  token: string,
  developerPayload?: string
) => Promise<PurchaseResult | void>;
/**
 * Consume a product (on Android.) No-op on iOS.
 * @param {string} token The product's token (on Android)
 * @returns {Promise<PurchaseResult>}
 */
declare export var consumePurchaseAndroid: (
  token: string,
  developerPayload?: string
) => Promise<PurchaseResult>;
/**
 * Should Add Store Payment (iOS only)
 *    Indicates the the App Store purchase should continue from the app instead of the App Store.
 * @returns {Promise<Product<>>}
 */
declare export var getPromotedProductIOS: () => Promise<string>;
/**
 * Buy the currently selected promoted product (iOS only)
 *    Initiates the payment process for a promoted product. Should only be called in response to the `iap-promoted-product` event.
 * @returns {Promise<void>}
 */
declare export var buyPromotedProductIOS: () => Promise<void>;
/**
 * Buy products or subscriptions with offers (iOS only)
 *
 * Runs the payment process with some infor you must fetch
 * from your server.
 * @param {string} sku The product identifier
 * @param {string} forUser An user identifier on you system
 * @param {Apple.PaymentDiscount} withOffer The offer information
 * @param {string} withOffer.identifier The offer identifier
 * @param {string} withOffer.keyIdentifier Key identifier that it uses to generate the signature
 * @param {string} withOffer.nonce An UUID returned from the server
 * @param {string} withOffer.signature The actual signature returned from the server
 * @param {number} withOffer.timestamp The timestamp of the signature
 * @returns {Promise<void>}
 */
declare export var requestPurchaseWithOfferIOS: (
  sku: string,
  forUser: string,
  withOffer: Apple.PaymentDiscount
) => Promise<void>;
/**
 * Validate receipt for iOS.
 * @param {{[key: string]: any}} receiptBody the receipt body to send to apple server.
 * @param {boolean} isTest whether this is in test environment which is sandbox.
 * @returns {Promise<Apple.ReceiptValidationResponse | false>}
 */
declare export var validateReceiptIos: (
  receiptBody: { [key: string]: mixed, ... },
  isTest?: boolean
) => Promise<Apple.ReceiptValidationResponse | false>;
/**
 * Validate receipt for Android.
 * @param {string} packageName package name of your app.
 * @param {string} productId product id for your in app product.
 * @param {string} productToken token for your purchase.
 * @param {string} accessToken accessToken from googleApis.
 * @param {boolean} isSub whether this is subscription or inapp. `true` for subscription.
 * @returns {Promise<{[key: string]: any}>}
 */
declare export var validateReceiptAndroid: (
  packageName: string,
  productId: string,
  productToken: string,
  accessToken: string,
  isSub?: boolean
) => Promise<{ [key: string]: mixed, ... } | false>;
/**
 * Add IAP purchase event in ios.
 * @returns {callback} (e: InAppPurchase | ProductPurchase)}
 */
declare export var purchaseUpdatedListener: (
  listener: (event: InAppPurchase | SubscriptionPurchase) => void
) => EmitterSubscription;
/**
 * Add IAP purchase error event in ios.
 * @returns {callback} (e: PurchaseError)}
 */
declare export var purchaseErrorListener: (
  listener: (errorEvent: PurchaseError) => void
) => EmitterSubscription;
/**
 * Get the current receipt base64 encoded in IOS.
 * @returns {Promise<string>}
 */
declare export var getReceiptIOS: () => Promise<string>;
/**
 * Get the pending purchases in IOS.
 * @returns {Promise<ProductPurchase[]>}
 */
declare export var getPendingPurchasesIOS: () => Promise<ProductPurchase[]>;
declare var iapUtils: {
  IAPErrorCode: typeof IAPErrorCode,
  initConnection: () => Promise<boolean>,
  endConnection: () => Promise<void>,
  endConnectionAndroid: () => Promise<void>,
  getProducts: <SkuType: string>(
    skus: SkuType[]
  ) => Promise<Product<SkuType>[]>,
  getSubscriptions: (skus: string[]) => Promise<Subscription[]>,
  getPurchaseHistory: () => Promise<(InAppPurchase | SubscriptionPurchase)[]>,
  getAvailablePurchases: () => Promise<
    (InAppPurchase | SubscriptionPurchase)[]
  >,
  getPendingPurchasesIOS: () => Promise<ProductPurchase[]>,
  consumeAllItemsAndroid: () => Promise<string[]>,
  flushFailedPurchasesCachedAsPendingAndroid: () => Promise<string[]>,
  clearProductsIOS: () => Promise<void>,
  clearTransactionIOS: () => Promise<void>,
  acknowledgePurchaseAndroid: (
    token: string,
    developerPayload?: string
  ) => Promise<PurchaseResult | void>,
  consumePurchaseAndroid: (
    token: string,
    developerPayload?: string
  ) => Promise<PurchaseResult>,
  validateReceiptIos: (
    receiptBody: { [key: string]: mixed, ... },
    isTest?: boolean
  ) => Promise<Apple.ReceiptValidationResponse | false>,
  validateReceiptAndroid: (
    packageName: string,
    productId: string,
    productToken: string,
    accessToken: string,
    isSub?: boolean
  ) => Promise<{ [key: string]: mixed, ... } | false>,
  requestPurchase: (
    sku: string,
    andDangerouslyFinishTransactionAutomaticallyIOS?: boolean,
    obfuscatedAccountIdAndroid?: string,
    obfuscatedProfileIdAndroid?: string
  ) => Promise<InAppPurchase>,
  requestPurchaseWithQuantityIOS: (
    sku: string,
    quantity: number
  ) => Promise<InAppPurchase>,
  finishTransactionIOS: (transactionId: string) => Promise<void>,
  finishTransaction: (
    purchase: InAppPurchase | ProductPurchase,
    isConsumable?: boolean,
    developerPayloadAndroid?: string
  ) => Promise<string | void>,
  requestSubscription: (
    sku: string,
    andDangerouslyFinishTransactionAutomaticallyIOS?: boolean,
    oldSkuAndroid?: string,
    purchaseTokenAndroid?: string,
    prorationModeAndroid?: $Values<typeof ProrationModesAndroid>,
    obfuscatedAccountIdAndroid?: string,
    obfuscatedProfileIdAndroid?: string
  ) => Promise<SubscriptionPurchase>,
  purchaseUpdatedListener: (
    listener: (event: InAppPurchase | SubscriptionPurchase) => void
  ) => EmitterSubscription,
  purchaseErrorListener: (
    listener: (errorEvent: PurchaseError) => void
  ) => EmitterSubscription,
  getReceiptIOS: () => Promise<string>,
  getPromotedProductIOS: () => Promise<string>,
  buyPromotedProductIOS: () => Promise<void>,
  ...
};
declare export default typeof iapUtils;
